// Code generated by capnpc-go. DO NOT EDIT.

package net

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	math "math"
	strconv "strconv"
)

type Vec3 capnp.Struct

// Vec3_TypeID is the unique identifier for the type Vec3.
const Vec3_TypeID = 0xc7e9576dd1cb2dc1

func NewVec3(s *capnp.Segment) (Vec3, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Vec3(st), err
}

func NewRootVec3(s *capnp.Segment) (Vec3, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Vec3(st), err
}

func ReadRootVec3(msg *capnp.Message) (Vec3, error) {
	root, err := msg.Root()
	return Vec3(root.Struct()), err
}

func (s Vec3) String() string {
	str, _ := text.Marshal(0xc7e9576dd1cb2dc1, capnp.Struct(s))
	return str
}

func (s Vec3) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Vec3) DecodeFromPtr(p capnp.Ptr) Vec3 {
	return Vec3(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Vec3) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Vec3) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Vec3) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Vec3) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Vec3) X() float32 {
	return math.Float32frombits(capnp.Struct(s).Uint32(0))
}

func (s Vec3) SetX(v float32) {
	capnp.Struct(s).SetUint32(0, math.Float32bits(v))
}

func (s Vec3) Y() float32 {
	return math.Float32frombits(capnp.Struct(s).Uint32(4))
}

func (s Vec3) SetY(v float32) {
	capnp.Struct(s).SetUint32(4, math.Float32bits(v))
}

func (s Vec3) Z() float32 {
	return math.Float32frombits(capnp.Struct(s).Uint32(8))
}

func (s Vec3) SetZ(v float32) {
	capnp.Struct(s).SetUint32(8, math.Float32bits(v))
}

// Vec3_List is a list of Vec3.
type Vec3_List = capnp.StructList[Vec3]

// NewVec3 creates a new list of Vec3.
func NewVec3_List(s *capnp.Segment, sz int32) (Vec3_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[Vec3](l), err
}

// Vec3_Future is a wrapper for a Vec3 promised by a client call.
type Vec3_Future struct{ *capnp.Future }

func (f Vec3_Future) Struct() (Vec3, error) {
	p, err := f.Future.Ptr()
	return Vec3(p.Struct()), err
}

type Packet capnp.Struct
type Packet_Which uint16

const (
	Packet_Which_auth Packet_Which = 0
	Packet_Which_move Packet_Which = 1
)

func (w Packet_Which) String() string {
	const s = "authmove"
	switch w {
	case Packet_Which_auth:
		return s[0:4]
	case Packet_Which_move:
		return s[4:8]

	}
	return "Packet_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Packet_TypeID is the unique identifier for the type Packet.
const Packet_TypeID = 0xc7ca850fead659c0

func NewPacket(s *capnp.Segment) (Packet, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Packet(st), err
}

func NewRootPacket(s *capnp.Segment) (Packet, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Packet(st), err
}

func ReadRootPacket(msg *capnp.Message) (Packet, error) {
	root, err := msg.Root()
	return Packet(root.Struct()), err
}

func (s Packet) String() string {
	str, _ := text.Marshal(0xc7ca850fead659c0, capnp.Struct(s))
	return str
}

func (s Packet) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Packet) DecodeFromPtr(p capnp.Ptr) Packet {
	return Packet(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Packet) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s Packet) Which() Packet_Which {
	return Packet_Which(capnp.Struct(s).Uint16(0))
}
func (s Packet) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Packet) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Packet) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Packet) Auth() (AuthPacket, error) {
	if capnp.Struct(s).Uint16(0) != 0 {
		panic("Which() != auth")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return AuthPacket(p.Struct()), err
}

func (s Packet) HasAuth() bool {
	if capnp.Struct(s).Uint16(0) != 0 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Packet) SetAuth(v AuthPacket) error {
	capnp.Struct(s).SetUint16(0, 0)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewAuth sets the auth field to a newly
// allocated AuthPacket struct, preferring placement in s's segment.
func (s Packet) NewAuth() (AuthPacket, error) {
	capnp.Struct(s).SetUint16(0, 0)
	ss, err := NewAuthPacket(capnp.Struct(s).Segment())
	if err != nil {
		return AuthPacket{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Packet) Move() (MovePacket, error) {
	if capnp.Struct(s).Uint16(0) != 1 {
		panic("Which() != move")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return MovePacket(p.Struct()), err
}

func (s Packet) HasMove() bool {
	if capnp.Struct(s).Uint16(0) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Packet) SetMove(v MovePacket) error {
	capnp.Struct(s).SetUint16(0, 1)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewMove sets the move field to a newly
// allocated MovePacket struct, preferring placement in s's segment.
func (s Packet) NewMove() (MovePacket, error) {
	capnp.Struct(s).SetUint16(0, 1)
	ss, err := NewMovePacket(capnp.Struct(s).Segment())
	if err != nil {
		return MovePacket{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Packet_List is a list of Packet.
type Packet_List = capnp.StructList[Packet]

// NewPacket creates a new list of Packet.
func NewPacket_List(s *capnp.Segment, sz int32) (Packet_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[Packet](l), err
}

// Packet_Future is a wrapper for a Packet promised by a client call.
type Packet_Future struct{ *capnp.Future }

func (f Packet_Future) Struct() (Packet, error) {
	p, err := f.Future.Ptr()
	return Packet(p.Struct()), err
}
func (p Packet_Future) Auth() AuthPacket_Future {
	return AuthPacket_Future{Future: p.Future.Field(0, nil)}
}
func (p Packet_Future) Move() MovePacket_Future {
	return MovePacket_Future{Future: p.Future.Field(0, nil)}
}

type AuthPacket capnp.Struct

// AuthPacket_TypeID is the unique identifier for the type AuthPacket.
const AuthPacket_TypeID = 0xfe26553a53d9d276

func NewAuthPacket(s *capnp.Segment) (AuthPacket, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return AuthPacket(st), err
}

func NewRootAuthPacket(s *capnp.Segment) (AuthPacket, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return AuthPacket(st), err
}

func ReadRootAuthPacket(msg *capnp.Message) (AuthPacket, error) {
	root, err := msg.Root()
	return AuthPacket(root.Struct()), err
}

func (s AuthPacket) String() string {
	str, _ := text.Marshal(0xfe26553a53d9d276, capnp.Struct(s))
	return str
}

func (s AuthPacket) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (AuthPacket) DecodeFromPtr(p capnp.Ptr) AuthPacket {
	return AuthPacket(capnp.Struct{}.DecodeFromPtr(p))
}

func (s AuthPacket) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s AuthPacket) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s AuthPacket) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s AuthPacket) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s AuthPacket) Token() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s AuthPacket) SetToken(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

// AuthPacket_List is a list of AuthPacket.
type AuthPacket_List = capnp.StructList[AuthPacket]

// NewAuthPacket creates a new list of AuthPacket.
func NewAuthPacket_List(s *capnp.Segment, sz int32) (AuthPacket_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[AuthPacket](l), err
}

// AuthPacket_Future is a wrapper for a AuthPacket promised by a client call.
type AuthPacket_Future struct{ *capnp.Future }

func (f AuthPacket_Future) Struct() (AuthPacket, error) {
	p, err := f.Future.Ptr()
	return AuthPacket(p.Struct()), err
}

type MovePacket capnp.Struct

// MovePacket_TypeID is the unique identifier for the type MovePacket.
const MovePacket_TypeID = 0xd5b795949bdeb67a

func NewMovePacket(s *capnp.Segment) (MovePacket, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return MovePacket(st), err
}

func NewRootMovePacket(s *capnp.Segment) (MovePacket, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return MovePacket(st), err
}

func ReadRootMovePacket(msg *capnp.Message) (MovePacket, error) {
	root, err := msg.Root()
	return MovePacket(root.Struct()), err
}

func (s MovePacket) String() string {
	str, _ := text.Marshal(0xd5b795949bdeb67a, capnp.Struct(s))
	return str
}

func (s MovePacket) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (MovePacket) DecodeFromPtr(p capnp.Ptr) MovePacket {
	return MovePacket(capnp.Struct{}.DecodeFromPtr(p))
}

func (s MovePacket) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s MovePacket) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s MovePacket) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s MovePacket) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s MovePacket) Uid() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s MovePacket) SetUid(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s MovePacket) Position() (Vec3, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Vec3(p.Struct()), err
}

func (s MovePacket) HasPosition() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s MovePacket) SetPosition(v Vec3) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewPosition sets the position field to a newly
// allocated Vec3 struct, preferring placement in s's segment.
func (s MovePacket) NewPosition() (Vec3, error) {
	ss, err := NewVec3(capnp.Struct(s).Segment())
	if err != nil {
		return Vec3{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s MovePacket) Rot() float32 {
	return math.Float32frombits(capnp.Struct(s).Uint32(8))
}

func (s MovePacket) SetRot(v float32) {
	capnp.Struct(s).SetUint32(8, math.Float32bits(v))
}

// MovePacket_List is a list of MovePacket.
type MovePacket_List = capnp.StructList[MovePacket]

// NewMovePacket creates a new list of MovePacket.
func NewMovePacket_List(s *capnp.Segment, sz int32) (MovePacket_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1}, sz)
	return capnp.StructList[MovePacket](l), err
}

// MovePacket_Future is a wrapper for a MovePacket promised by a client call.
type MovePacket_Future struct{ *capnp.Future }

func (f MovePacket_Future) Struct() (MovePacket, error) {
	p, err := f.Future.Ptr()
	return MovePacket(p.Struct()), err
}
func (p MovePacket_Future) Position() Vec3_Future {
	return Vec3_Future{Future: p.Future.Field(0, nil)}
}

const schema_9c4788c5a214e29c = "x\xdat\x91\xbd\xab\xd3P\x18\x87\xdf\xdf{r\xcd\xbd" +
	"\x97\x1b\x9a\x98\xec\x8a\x88\xa8P\xf1k\xba\x8bW\xb0h" +
	"\xa5\x81\x1c\xfc\x1eC\x0c\xb4\x946E\xd3\xaa\xdd\x05g" +
	"\xd1\xc9N\xdd\x1cD\\t\xd5\x82\x14tRPpq" +
	"\x10\x1c*\xf8\x0f8\xf4\xc89\xa5\x89\x04\xdc^\x1e\x1e" +
	"\xf2\xfc\xc2q\xff\xecY\xa7\x9c9\x13\xcb\x83\x1b\xfb\xd4" +
	"\xdb[_\x7f\xd5\x1e~\x98\x93t\x005\xf9\x11L\xdf" +
	"?\xba8\xa1\x06l&\xf2\x9b\x98\xfa\x126\x91\x1f\xe2" +
	"\x1eA\xbd\xab\x7f\xfc\xd4\xbb\xb106\x97\xb6\xa5\x8d\xe7" +
	"x\xec\xbf2\xee\x0b\xbc$\xa8\xf1\xeb\xef\xcf\x9e<}" +
	"\xf3\xa5\xe2n\x18\xa5\xc13?d}5Y\xcb\xa3\xcf" +
	"\xdf\xae\xec^;\xb2\xac\xcc0\x1f\xfe\xc93\xff\xb7q" +
	"\x17|\x8e\xeaj\x10'\xdd4?\x91 \x1e\xf4\x07\xbb" +
	"Q\x9c\xd8\xdd4\x8f\x00\xb9)\xac\x1d\xa5,\x10y\xc7" +
	"\x8e\x13\xc9\xc3\x02\xf2$\xc3\xc1R\x05\xd0\xb4\xae\xe9Q" +
	"\x01y\x96Q\x8b\x87y\x1bnY&\xc0%\xd4z\xd9" +
	"(\x85[\xae_\xe1J\xf4z\x9a\xe0\x8cN\xee\x08\x8b" +
	"\xc8\x14\x1b\xfb\x89\xe4\x9e\x80l1<`\x15ljx" +
	"A@F\x0c\x8f9\x00\x13y\xa1\x86\x97\x04\xe4U\x06" +
	"\xeec\x9b\x18\xdb\x04<(\xae\xf1\xfa*\xaal\xaaa" +
	"6J#C\xa8\xd2>T\xb6\x8b\xf4\xe5\xb2R\xa4\xa5" +
	"\x16[\x02\xf2&\xc3\x1evnc\x8b\x18[:\x94\xdd" +
	"\xed\xe4\x9d\xacODp\xcbg^\xfd\xbc}'\xcb\xff" +
	"3\xe9\xfc0o\xff3\xc9*&9\xa7\x89\xe4\xa6\x80" +
	"\x0c\x18\x07\xf2\xac\x9b\xf6\xd7\xad\xbf\x01\x00\x00\xff\xffI" +
	"f\x98l"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_9c4788c5a214e29c,
		Nodes: []uint64{
			0xc7ca850fead659c0,
			0xc7e9576dd1cb2dc1,
			0xd5b795949bdeb67a,
			0xfe26553a53d9d276,
		},
		Compressed: true,
	})
}
